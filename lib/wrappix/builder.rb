# frozen_string_literal: true

require "yaml"
require "fileutils"
require_relative "templates/configuration"
require_relative "templates/client"
require_relative "templates/request"
require_relative "templates/error"
require_relative "templates/resource"
require_relative "templates/main"
require_relative "templates/readme"
require_relative "templates/cache"
require_relative "templates/collection"
require_relative "templates/object"
require_relative "templates/documentation"
require_relative "templates/tests"

module Wrappix
  class Builder
    attr_reader :file_paths

    def initialize(config_file)
      raise Errno::ENOENT, "No such file or directory - #{config_file}" unless File.exist?(config_file)

      @config = YAML.load_file(config_file)
      @api_name = @config["api_name"] || File.basename(Dir.pwd)
      @normalized_api_name = @api_name.tr("-", "_")
      @module_name = @api_name.split("-").map(&:capitalize).join
      @file_paths = {}
    end

    def build
      process_response_format
      create_version_file
      create_base_files
      create_resource_files
      create_readme
      create_documentation
      create_test_files
      create_gemspec
      create_compatibility_file
      true
    rescue Psych::SyntaxError => e
      puts "Error de sintaxis en el archivo YAML: #{e.message}"
      false
    rescue StandardError => e
      puts "Error durante la construcción: #{e.message}"
      puts e.backtrace
      false
    end

    private

    def create_version_file
      create_file("lib/#{@normalized_api_name}/version.rb", <<~RUBY)
        # frozen_string_literal: true

        module #{@module_name}
          VERSION = "0.1.0"
        end
      RUBY
    end

    def process_response_format
      # Asegurarse de que existe una configuración global de formato de respuesta
      @config["response_format"] ||= {
        "collection_root" => "data",
        "pagination" => {
          "next_page_key" => "next_href",
          "total_count_key" => "total",
          "limit_key" => "limit"
        }
      }

      # Para cada recurso, establecer valores predeterminados si no están definidos
      resources = @config["resources"] || {}
      resources.each_value do |resource_config|
        resource_config["response_format"] ||= {}
      end
    end

    def create_base_files
      create_file("lib/#{@normalized_api_name}/configuration.rb",
                  Templates::Configuration.render(@module_name, @config))
      create_file("lib/#{@normalized_api_name}/client.rb", Templates::Client.render(@module_name, @config))
      create_file("lib/#{@normalized_api_name}/request.rb", Templates::Request.render(@module_name, @config))
      create_file("lib/#{@normalized_api_name}/error.rb", Templates::Error.render(@module_name, @config))
      create_file("lib/#{@normalized_api_name}/cache.rb", Templates::Cache.render(@module_name, @config))
      create_file("lib/#{@normalized_api_name}/object.rb", Templates::Object.render(@module_name, @config))
      create_file("lib/#{@normalized_api_name}/collection.rb", Templates::Collection.render(@module_name, @config))
      update_main_file
    end

    def create_test_files
      FileUtils.mkdir_p("test")

      # Crear un archivo test_helper.rb básico
      create_file("test/test_helper.rb", <<~RUBY)
        require "minitest/autorun"
        require "faraday"
        require "json"

        $LOAD_PATH.unshift File.expand_path("../lib", __dir__)
        require "#{@normalized_api_name}"

        # Configuración global para las pruebas
        #{@module_name}.configure do |config|
          config.base_url = "https://api.example.com"
          # Otras configuraciones necesarias
        end
      RUBY

      # Crear el archivo de tests principal con nombre normalizado
      create_file(
        "test/#{@normalized_api_name}_test.rb",
        Templates::Tests.render(@api_name, @module_name, @config)
      )
    end

    def create_gemspec
      create_file("#{@api_name}.gemspec", <<~RUBY)
        # frozen_string_literal: true

        require_relative "lib/#{@normalized_api_name}/version"

        Gem::Specification.new do |spec|
          spec.name          = "#{@api_name}"
          spec.version       = #{@module_name}::VERSION
          spec.authors       = ["Generated by Wrappix"]
          spec.email         = ["info@example.com"]

          spec.summary       = "API wrapper for #{@api_name}"
          spec.description   = "A Ruby client for the #{@api_name} API"
          spec.homepage      = "https://github.com/example/#{@api_name}"
          spec.license       = "MIT"
          spec.required_ruby_version = ">= 2.6.0"

          spec.metadata["homepage_uri"] = spec.homepage

          # Specify which files should be added to the gem when it is released.
          spec.files = Dir["lib/**/*", "LICENSE.txt", "README.md"]

          spec.add_dependency "faraday", "~> 2.0"
          spec.add_dependency "faraday_middleware", "~> 1.2"
          spec.add_dependency "ostruct", "~> 0.5"

          spec.add_development_dependency "minitest", "~> 5.0"
          spec.add_development_dependency "rake", "~> 13.0"
        end
      RUBY
    end

    def create_resource_files
      FileUtils.mkdir_p("lib/#{@normalized_api_name}/resources")

      resources = @config["resources"] || {}
      resources.each do |resource_name, resource_config|
        create_file(
          "lib/#{@normalized_api_name}/resources/#{resource_name}.rb",
          Templates::Resource.render(@module_name, resource_name, resource_config)
        )
      end
    end

    def update_main_file
      main_file = "lib/#{@normalized_api_name}.rb"
      content = Templates::Main.render(@normalized_api_name, @module_name, @config)
      create_file(main_file, content)
    end

    def create_compatibility_file
      # Crear un archivo de compatibilidad con el nombre original (si es diferente)
      return unless @api_name != @normalized_api_name

      compat_file = "lib/#{@api_name}.rb"
      content = <<~RUBY
        # frozen_string_literal: true

        # Archivo de compatibilidad - redirige al archivo normalizado
        require_relative "#{@normalized_api_name}"
      RUBY
      create_file(compat_file, content)
    end

    def create_file(path, content)
      FileUtils.mkdir_p(File.dirname(path))

      File.open(path, "w") do |file|
        file.write(content)
      end

      @file_paths[path] = true
      puts "File created: #{path}"

      true
    end

    def create_readme
      create_file("README.md", Templates::Readme.render(@api_name, @module_name, @config))
    end

    def create_documentation
      FileUtils.mkdir_p("docs")
      create_file("docs/api.md", Templates::Documentation.render(@api_name, @module_name, @config))
    end
  end
end
